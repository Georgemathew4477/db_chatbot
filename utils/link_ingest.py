# utils/link_ingest.py

import os
import re
import tempfile
from typing import Dict, Optional, Union

# Optional deps
try:
    import yt_dlp
    HAVE_YT_DLP = True
except Exception:
    HAVE_YT_DLP = False


try:
    import ffmpeg
    HAVE_FFMPEG = True
except Exception:
    HAVE_FFMPEG = False
try:
    import imageio_ffmpeg  # pulls a bundled ffmpeg binary
    FFMPEG_BIN = imageio_ffmpeg.get_ffmpeg_exe()
    # imageio-ffmpeg 0.4.9+ also exposes get_ffprobe_exe(); if missing, fallback
    FFPROBE_BIN = getattr(imageio_ffmpeg, "get_ffprobe_exe", lambda: "ffprobe")()
    HAVE_FFMPEG = True
except Exception:
    # fallback to PATH
    FFMPEG_BIN = os.getenv("FFMPEG_PATH") or "ffmpeg"
    FFPROBE_BIN = os.getenv("FFPROBE_PATH") or "ffprobe"


try:
    from youtube_transcript_api import (
        YouTubeTranscriptApi,
        TranscriptsDisabled,
        NoTranscriptFound,
        VideoUnavailable,
    )
    HAVE_YT_TRANSCRIPT = True
except Exception:
    HAVE_YT_TRANSCRIPT = False

# Shared yt-dlp options (quiet + no playlists)
# --- Shared yt-dlp options (Cloud-safe) ---
YDL_COMMON_OPTS = {
    "quiet": True,
    "no_warnings": True,
    "noprogress": True,
    "ignoreerrors": False,
    "retries": 5,
    "fragment_retries": 5,
    "socket_timeout": 20,
    "concurrent_fragment_downloads": 1,
    "noplaylist": True,
    "playlist_items": "1",
    "overwrites": True,
    # IMPORTANT: give ffmpeg path if we discovered one via imageio-ffmpeg
    "ffmpeg_location": FFMPEG_BIN if HAVE_FFMPEG else None,
}


def _file_ok(path: Optional[str]) -> bool:
    try:
        return bool(path) and os.path.exists(path) and os.path.getsize(path) > 16_384  # >16KB
    except Exception:
        return False

# ---------------------------
# URL Helpers
# ---------------------------
def is_youtube_url(url: str) -> bool:
    return bool(re.search(r"(youtube\.com/watch\?v=|youtu\.be/|youtube\.com/shorts/)", url or "", re.I))

def is_youtube_shorts(url: str) -> bool:
    return bool(re.search(r"youtube\.com/shorts/", url or "", re.I))

def _extract_yt_id(url: str) -> Optional[str]:
    if not url:
        return None
    for pat in [
        r"youtu\.be/([A-Za-z0-9_\-]{6,})",
        r"[?&]v=([A-Za-z0-9_\-]{6,})",
        r"youtube\.com/shorts/([A-Za-z0-9_\-]{6,})",
    ]:
        m = re.search(pat, url)
        if m:
            return m.group(1)
    return None

# ---------------------------
# Captions (non-Shorts)
# ---------------------------
def fetch_youtube_transcript(yt_id: str, languages=("en", "en-US", "en-GB")) -> Optional[str]:
    """Try human captions first, then autogenerated. Returns text or None."""
    if not (HAVE_YT_TRANSCRIPT and yt_id):
        return None
    try:
        # Human captions first
        for lang in languages:
            try:
                segs = YouTubeTranscriptApi.get_transcript(yt_id, languages=[lang])
                if segs:
                    return " ".join(s.get("text", "").strip() for s in segs if s.get("text")).strip()
            except (NoTranscriptFound, TranscriptsDisabled):
                pass
        # Auto captions
        try:
            lst = YouTubeTranscriptApi.list_transcripts(yt_id)
            auto = lst.find_generated_transcript(languages=list(languages))
            segs = auto.fetch()
            if segs:
                return " ".join(s.get("text", "").strip() for s in segs if s.get("text")).strip()
        except Exception:
            pass
    except (TranscriptsDisabled, NoTranscriptFound, VideoUnavailable, Exception):
        return None
    return None

# ---------------------------
# Description (context only)
# ---------------------------
def fetch_youtube_description(url: str) -> Optional[str]:
    """Use yt_dlp to extract title + description (no download)."""
    if not (HAVE_YT_DLP and url):
        return None
    ydl_opts = {
        **YDL_COMMON_OPTS,
        "skip_download": True,
        "extract_flat": True,
        "forcejson": True,
        "dump_single_json": True,
    }
    try:
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(url, download=False)
            if not info:
                return None
            if info.get("_type") == "playlist" and info.get("entries"):
                info = info["entries"][0]
            title = (info.get("title") or "").strip()
            desc = (info.get("description") or "").strip()
            out = f"{title}\n\n{desc}".strip()
            return out or None
    except Exception:
        return None

# ---------------------------
# Download AUDIO (always)
# ---------------------------
def download_video_with_ytdlp(url: str) -> Optional[Dict[str, Union[str, int, None]]]:
    if not (HAVE_YT_DLP and url):
        return None

    tmpdir = tempfile.mkdtemp(prefix="yt-video-")
    outtmpl = "%(id)s.%(ext)s"

    ydl_opts = {
        **YDL_COMMON_OPTS,
        "format": "bv*+ba/b",  # bestvideo+audio merged (needs ffmpeg)
        "merge_output_format": "mp4",
        "paths": {"home": tmpdir, "temp": tmpdir},
        "outtmpl": {"default": outtmpl},
        "ffmpeg_location": os.getenv("FFMPEG_PATH") or None,
        "match_filter": yt_dlp.utils.match_filter_func("!is_live & !was_live"),
    }
    try:
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(url, download=True)
            if not info: return None
            if info.get("_type") == "playlist":
                info = (info.get("entries") or [None])[0] or info
            vid = info.get("id") or ""
            ext = info.get("ext") or "mp4"
            candidate = os.path.join(tmpdir, f"{vid}.{ext}")
            if not os.path.exists(candidate):
                # scan dir for any file starting with the id
                for fn in os.listdir(tmpdir):
                    if fn.startswith(vid + "."):
                        candidate = os.path.join(tmpdir, fn); break
            if not (os.path.exists(candidate) and os.path.getsize(candidate) > 16384):
                return None
            return {
                "path": candidate,
                "id": vid,
                "title": (info.get("title") or "").strip(),
                "duration": info.get("duration"),
                "ext": os.path.splitext(candidate)[1].lstrip("."),
            }
    except Exception:
        return None


def download_audio_with_ytdlp(url: str):
    if not (HAVE_YT_DLP and url):
        return None
    tmpdir = tempfile.mkdtemp(prefix="yt-audio-")
    outtmpl = os.path.join(tmpdir, "%(id)s.%(ext)s")

    # Prefer m4a if available, else webm/opus
    ydl_opts = {
        **YDL_COMMON_OPTS,
        "format": "bestaudio[ext=m4a]/bestaudio/best",
        "outtmpl": outtmpl,
        # no re-encode postprocessor; we’ll convert later if needed
        "postprocessors": [],
        "merge_output_format": None,
    }

    try:
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(url, download=True)
        if not info:
            return None
        if info.get("_type") == "playlist":
            info = (info.get("entries") or [None])[0] or info

        vid = info.get("id") or ""
        # resolve file
        candidate = None
        for fn in os.listdir(tmpdir):
            if fn.startswith(vid + "."):
                candidate = os.path.join(tmpdir, fn)
                break
        if candidate and os.path.getsize(candidate) > 16384:
            return {
                "path": candidate,
                "id": vid,
                "title": (info.get("title") or "").strip(),
                "duration": info.get("duration"),
            }
        return None
    except Exception as e:
        # surface the error up to the UI
        return {"error": f"yt-dlp audio error: {e!r}"}


# ---------------------------
# Orchestrator (simple & reliable)
# ---------------------------
def ingest_from_url(url: str) -> Dict:
    """
    Strategy:
      - If NOT Shorts and official/auto captions exist → include them as 'text' (fast).
      - ALWAYS download bestaudio and return as 'audio_path' (works for Shorts & normal).
      - We do NOT download video: avoids silent MP4 merges and weird muxes.
      - Description is returned as context only (never treated as transcript).
    """
    url = (url or "").strip()
    if not url:
        return {"kind": "invalid", "text": None, "audio_path": None, "video_path": None, "note": "Empty URL."}

    if is_youtube_url(url):
        vid = _extract_yt_id(url)
        shorts = is_youtube_shorts(url)

        # Captions (non-Shorts only)
        tx = fetch_youtube_transcript(vid) if (vid and not shorts) else None

        # Always fetch description as context (never used as transcript for Shorts)
        desc = fetch_youtube_description(url)

        # Always download audio for STT (robust for both Shorts and normal)
        ainfo = download_audio_with_ytdlp(url)
        audio_path = ainfo["path"] if isinstance(ainfo, dict) else None
        note_bits = []
        if audio_path:
            note_bits.append(f"Downloaded bestaudio. id={(ainfo or {}).get('id', vid)} title={repr((ainfo or {}).get('title'))} dur≈{(ainfo or {}).get('duration')}s")
        if tx:
            note_bits.append("Got official/auto captions.")
        if desc:
            note_bits.append("Fetched description.")

        kind = (
            "youtube_transcript" if tx else
            "youtube_audio" if audio_path else
            "youtube_description" if desc else
            "youtube_fallback"
        )

        # Only non-Shorts get text prefilled; Shorts text stays None
        safe_text = tx if not shorts else None

        return {
            "kind": kind,
            "text": safe_text,
            "video_path": None,     # simplified: we don't download video
            "audio_path": audio_path,
            "note": " ".join(note_bits) or f"Ingested YouTube id={vid or '?'}",
        }

    # Non-YouTube not implemented
    return {
        "kind": "unsupported",
        "text": None,
        "video_path": None,
        "audio_path": None,
        "note": "Only YouTube is supported in this demo.",
    }
