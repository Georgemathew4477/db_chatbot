# utils/link_ingest.py

import os
import re
import tempfile
from typing import Dict, Optional, Union

# Optional deps
try:
    import yt_dlp
    HAVE_YT_DLP = True
except Exception:
    HAVE_YT_DLP = False

try:
    from youtube_transcript_api import (
        YouTubeTranscriptApi,
        TranscriptsDisabled,
        NoTranscriptFound,
        VideoUnavailable,
    )
    HAVE_YT_TRANSCRIPT = True
except Exception:
    HAVE_YT_TRANSCRIPT = False

# Shared yt-dlp options (quiet + no playlists)
YDL_COMMON_OPTS = {
    "quiet": True,
    "no_warnings": True,
    "noprogress": True,
    "ignoreerrors": False,
    "retries": 5,
    "fragment_retries": 5,
    "socket_timeout": 20,
    "concurrent_fragment_downloads": 1,
    "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64)",
    "noplaylist": True,
    "playlist_items": "1",
    "overwrites": True,
    # "cookiefile": os.getenv("YTDLP_COOKIES"),
}

def _file_ok(path: Optional[str]) -> bool:
    try:
        return bool(path) and os.path.exists(path) and os.path.getsize(path) > 16_384  # >16KB
    except Exception:
        return False

# ---------------------------
# URL Helpers
# ---------------------------
def is_youtube_url(url: str) -> bool:
    return bool(re.search(r"(youtube\.com/watch\?v=|youtu\.be/|youtube\.com/shorts/)", url or "", re.I))

def is_youtube_shorts(url: str) -> bool:
    return bool(re.search(r"youtube\.com/shorts/", url or "", re.I))

def _extract_yt_id(url: str) -> Optional[str]:
    if not url:
        return None
    for pat in [
        r"youtu\.be/([A-Za-z0-9_\-]{6,})",
        r"[?&]v=([A-Za-z0-9_\-]{6,})",
        r"youtube\.com/shorts/([A-Za-z0-9_\-]{6,})",
    ]:
        m = re.search(pat, url)
        if m:
            return m.group(1)
    return None

# ---------------------------
# Captions (non-Shorts)
# ---------------------------
def fetch_youtube_transcript(yt_id: str, languages=("en", "en-US", "en-GB")) -> Optional[str]:
    """Try human captions first, then autogenerated. Returns text or None."""
    if not (HAVE_YT_TRANSCRIPT and yt_id):
        return None
    try:
        # Human captions first
        for lang in languages:
            try:
                segs = YouTubeTranscriptApi.get_transcript(yt_id, languages=[lang])
                if segs:
                    return " ".join(s.get("text", "").strip() for s in segs if s.get("text")).strip()
            except (NoTranscriptFound, TranscriptsDisabled):
                pass
        # Auto captions
        try:
            lst = YouTubeTranscriptApi.list_transcripts(yt_id)
            auto = lst.find_generated_transcript(languages=list(languages))
            segs = auto.fetch()
            if segs:
                return " ".join(s.get("text", "").strip() for s in segs if s.get("text")).strip()
        except Exception:
            pass
    except (TranscriptsDisabled, NoTranscriptFound, VideoUnavailable, Exception):
        return None
    return None

# ---------------------------
# Description (context only)
# ---------------------------
def fetch_youtube_description(url: str) -> Optional[str]:
    """Use yt_dlp to extract title + description (no download)."""
    if not (HAVE_YT_DLP and url):
        return None
    ydl_opts = {
        **YDL_COMMON_OPTS,
        "skip_download": True,
        "extract_flat": True,
        "forcejson": True,
        "dump_single_json": True,
    }
    try:
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(url, download=False)
            if not info:
                return None
            if info.get("_type") == "playlist" and info.get("entries"):
                info = info["entries"][0]
            title = (info.get("title") or "").strip()
            desc = (info.get("description") or "").strip()
            out = f"{title}\n\n{desc}".strip()
            return out or None
    except Exception:
        return None

# ---------------------------
# Download AUDIO (always)
# ---------------------------
def download_audio_with_ytdlp(url: str) -> Optional[Dict[str, Union[str, int, None]]]:
    """
    Download bestaudio/best as-is (no re-encode).
    Returns: {"path","id","title","duration"} or None.
    """
    if not (HAVE_YT_DLP and url):
        return None

    tmpdir = tempfile.mkdtemp(prefix="yt-audio-")
    outtmpl = os.path.join(tmpdir, "%(id)s.%(ext)s")

    ydl_opts = {
        **YDL_COMMON_OPTS,
        "extract_flat": False,
        "outtmpl": outtmpl,
        "format": "bestaudio/best",
        "ffmpeg_location": os.getenv("FFMPEG_PATH") or None,  # use PATH or provided
        "postprocessors": [],  # avoid re-encode/trim; we handle WAV conversion in STT
        "match_filter": yt_dlp.utils.match_filter_func("!is_live & !was_live"),
    }

    try:
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(url, download=True)
            if not info:
                return None
            if info.get("_type") == "playlist":
                entry = (info.get("entries") or [None])[0]
                info = entry or info

            vid = info.get("id") or ""
            title = (info.get("title") or "").strip()
            duration = info.get("duration")
            ext = info.get("ext") or "m4a"
            candidate = os.path.join(tmpdir, f"{vid}.{ext}")

            if not os.path.exists(candidate):
                # Fallback: scan the temp dir for any file with that id prefix
                for fn in os.listdir(tmpdir):
                    if fn.startswith(vid + "."):
                        candidate = os.path.join(tmpdir, fn)
                        break

            if not _file_ok(candidate):
                return None

            return {"path": candidate, "id": vid, "title": title, "duration": duration}
    except Exception:
        return None

# ---------------------------
# Orchestrator (simple & reliable)
# ---------------------------
def ingest_from_url(url: str) -> Dict:
    """
    Strategy:
      - If NOT Shorts and official/auto captions exist → include them as 'text' (fast).
      - ALWAYS download bestaudio and return as 'audio_path' (works for Shorts & normal).
      - We do NOT download video: avoids silent MP4 merges and weird muxes.
      - Description is returned as context only (never treated as transcript).
    """
    url = (url or "").strip()
    if not url:
        return {"kind": "invalid", "text": None, "audio_path": None, "video_path": None, "note": "Empty URL."}

    if is_youtube_url(url):
        vid = _extract_yt_id(url)
        shorts = is_youtube_shorts(url)

        # Captions (non-Shorts only)
        tx = fetch_youtube_transcript(vid) if (vid and not shorts) else None

        # Always fetch description as context (never used as transcript for Shorts)
        desc = fetch_youtube_description(url)

        # Always download audio for STT (robust for both Shorts and normal)
        ainfo = download_audio_with_ytdlp(url)
        audio_path = ainfo["path"] if isinstance(ainfo, dict) else None
        note_bits = []
        if audio_path:
            note_bits.append(f"Downloaded bestaudio. id={(ainfo or {}).get('id', vid)} title={repr((ainfo or {}).get('title'))} dur≈{(ainfo or {}).get('duration')}s")
        if tx:
            note_bits.append("Got official/auto captions.")
        if desc:
            note_bits.append("Fetched description.")

        kind = (
            "youtube_transcript" if tx else
            "youtube_audio" if audio_path else
            "youtube_description" if desc else
            "youtube_fallback"
        )

        # Only non-Shorts get text prefilled; Shorts text stays None
        safe_text = tx if not shorts else None

        return {
            "kind": kind,
            "text": safe_text,
            "video_path": None,     # simplified: we don't download video
            "audio_path": audio_path,
            "note": " ".join(note_bits) or f"Ingested YouTube id={vid or '?'}",
        }

    # Non-YouTube not implemented
    return {
        "kind": "unsupported",
        "text": None,
        "video_path": None,
        "audio_path": None,
        "note": "Only YouTube is supported in this demo.",
    }
